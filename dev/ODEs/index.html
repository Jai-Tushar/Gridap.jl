<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A general framework for the numerical approximation of ODEs · Gridap.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Gridap.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Gridap.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting-started/">Getting Started</a></li><li><a class="tocitem" href="../Gridap/">Gridap</a></li><li><a class="tocitem" href="../Helpers/">Gridap.Helpers</a></li><li><a class="tocitem" href="../Io/">Gridap.Io</a></li><li><a class="tocitem" href="../Algebra/">Gridap.Algebra</a></li><li><a class="tocitem" href="../Arrays/">Gridap.Arrays</a></li><li><a class="tocitem" href="../TensorValues/">Gridap.TensorValues</a></li><li><a class="tocitem" href="../Fields/">Gridap.Fields</a></li><li><a class="tocitem" href="../Polynomials/">Gridap.Polynomials</a></li><li><a class="tocitem" href="../ReferenceFEs/">Gridap.ReferenceFEs</a></li><li><a class="tocitem" href="../Geometry/">Gridap.Geometry</a></li><li><a class="tocitem" href="../CellData/">Gridap.CellData</a></li><li><a class="tocitem" href="../Visualization/">Gridap.Visualization</a></li><li><a class="tocitem" href="../FESpaces/">Gridap.FESpaces</a></li><li><a class="tocitem" href="../MultiField/">Gridap.MultiField</a></li><li><a class="tocitem" href="../Adaptivity/">Gridap.Adaptivity</a></li><li><span class="tocitem">Developper notes</span><ul><li><a class="tocitem" href="../dev-notes/block-assemblers/">Block Assemblers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A general framework for the numerical approximation of ODEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A general framework for the numerical approximation of ODEs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/gridap/Gridap.jl/blob/master/docs/src/ODEs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-general-framework-for-the-numerical-approximation-of-ODEs"><a class="docs-heading-anchor" href="#A-general-framework-for-the-numerical-approximation-of-ODEs">A general framework for the numerical approximation of ODEs</a><a id="A-general-framework-for-the-numerical-approximation-of-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#A-general-framework-for-the-numerical-approximation-of-ODEs" title="Permalink"></a></h1><p>We consider an initial value problem written in the form</p><p class="math-container">\[\left\{\begin{array}{rcll}\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) &amp;=&amp; \boldsymbol{0}_{d}, \\ \partial_{t}^{k} \boldsymbol{u}(t_{0}) &amp;=&amp; \boldsymbol{u}_{0}^{k} &amp; 0 \leq k \leq n-1,\end{array}\right.\]</p><p>where</p><ul><li><p class="math-container">\[\boldsymbol{u}: \mathbb{R} \to \mathbb{R}^{d}\]</p>is the unknown of the problem,</li><li><p class="math-container">\[n \in \mathbb{N}\]</p>is the order of the ODE,</li><li><p class="math-container">\[t_{0} \in \mathbb{R}\]</p>is the initial time and <span>$\\{\{\boldsymbol{u}\_{0}^{k}\}\\}\_{0 \leq k \leq n-1} \in (\mathbb{R}^{d})^{n-1}$</span> are the initial conditions, and</li><li><p class="math-container">\[\boldsymbol{r}: \mathbb{R} \times (\mathbb{R}^{d})^{n} \to \mathbb{R}^{d}\]</p>is the residual.</li></ul><blockquote><p>We illustrate these notations on the semi-discretisation of the heat equation. It is a first-order ODE so we have <span>$n = 1$</span>, and <span>$d$</span> is the number of degrees of freedom. The residual and initial condition have the form <span>$\boldsymbol{r}(t, \boldsymbol{u}, \dot{\boldsymbol{u}}) \doteq \boldsymbol{M} \dot{\boldsymbol{u}} + \boldsymbol{K}(t) \boldsymbol{u} - \boldsymbol{f}(t), \qquad \boldsymbol{u}(t_{0}),$</span> where <span>$\boldsymbol{M} \in \mathbb{R}^{d \times d}$</span> is the mass matrix, <span>$\boldsymbol{K}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> is the stiffness matrix, and <span>$\boldsymbol{f}: \mathbb{R} \to \mathbb{R}^{d}$</span> is the forcing term.</p></blockquote><p>Suppose that we are willing to approximate <span>$\boldsymbol{u}$</span> at a time <span>$t_{F} &gt; t_{0}$</span>. A numerical scheme splits the time interval <span>$[t_{0}, t_{F}]$</span> into smaller intervals <span>$[t_{n}, t_{n+1}]$</span> (that do not have to be of equal length) and propagates the information at time <span>$t_{n}$</span> to time <span>$t_{n+1}$</span>. More formally, we consider a general framework consisting of a starting, an update, and a finishing map defined as follows</p><ul><li>The <strong>starting map</strong> <span>$\mathcal{I}: (\mathbb{R}^{d})^{n} \to (\mathbb{R}^{d})^{s}$</span> converts the initial conditions into <span>$s$</span> state vectors, where <span>$s \geq n$</span>.</li><li>The <strong>marching map</strong> <span>$\mathcal{U}: \mathbb{R} \times (\mathbb{R}^{d})^{s} \to (\mathbb{R}^{d})^{s}$</span> updates the state vectors from time <span>$t_{n}$</span> to time <span>$t_{n+1}$</span>.</li><li>The <strong>finishing map</strong> <span>$\mathcal{F}: \mathbb{R} \times (\mathbb{R}^{d})^{s} \to \mathbb{R}^{d}$</span> converts the state vectors into the evaluation of <span>$\boldsymbol{u}$</span> at the current time.</li></ul><blockquote><p>In the simplest case, the time step <span>$h = h_{n} = t_{n+1} - t_{n}$</span> is prescribed and constant across all iterations. The state vectors are simply the initial conditions, i.e. <span>$s = n$</span> and <span>$\mathcal{I} = \mathrm{id}$</span>, and assuming that the initial conditions are given by increasing order of time derivative, <span>$\mathcal{F}$</span> returns its first input.</p><p>Some schemes need nontrivial starting and finishing maps. (See the generalised- <span>$\alpha$</span> schemes below.) When higher-order derivatives can be retrieved from the state vectors, it is also possible to take another definition for <span>$\mathcal{F}$</span> so that it returns the evaluation of <span>$\boldsymbol{u}$</span> and higher-order derivatives at the current time.</p></blockquote><p>These three maps need to be designed such that the following recurrence produces approximations of <span>$\boldsymbol{u}$</span> at the times of interest <span>$t_{n}$</span></p><p class="math-container">\[\left\{\begin{array}{rcl}
\left\{\boldsymbol{s}\right\}_{n+1} &amp;=&amp; \mathcal{U}(h_{n}, \left\{\boldsymbol{s}\right\}_{n}) \\
\left\{\boldsymbol{s}\right\}_{0} &amp;=&amp; \mathcal{I}(\boldsymbol{u}_{0}^{0}, \ldots, \boldsymbol{u}_{0}^{n-1})
\end{array}\right., \qquad \boldsymbol{u}_{n} = \mathcal{F}(\left\{\boldsymbol{s}\right\}_{n}).\]</p><p>More precisely, we would like <span>$\boldsymbol{u}\_{n}$</span> to be close to <span>$\boldsymbol{u}(t_{n})$</span>. Here the notation <span>$\\{\boldsymbol{s}\\}\_{n}$</span> stands for the state vector, i.e. a vector of <span>$s$</span> vectors: <span>$\\{\boldsymbol{s}\\}\_{n} = (\boldsymbol{s}\_{n, i})\_{1 \leq i \leq s}$</span>. In particular, we notice that we need the exactness condition <span>$\mathcal{F} \circ \mathcal{I}(\boldsymbol{u}\_{0}^{0}, \ldots, \boldsymbol{u}\_{0}^{n-1}) = \boldsymbol{u}_{0}$</span>. This is a condition on the design of the pair (<span>$\mathcal{I}$</span>, <span>$\mathcal{F}$</span>).</p><h1 id="Classification-of-ODEs-and-numerical-schemes"><a class="docs-heading-anchor" href="#Classification-of-ODEs-and-numerical-schemes">Classification of ODEs and numerical schemes</a><a id="Classification-of-ODEs-and-numerical-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-ODEs-and-numerical-schemes" title="Permalink"></a></h1><p>Essentially, a numerical scheme converts a (continuous) ODE into (discrete) nonlinear systems of equations. These systems of equations can be linear under special conditions on the nature of the ODE and the numerical scheme. Since numerical methods for linear and nonlinear systems of equations can be quite different in terms of cost and implementation, we are interested in solving linear systems whenever possible. This leads us to perform the following classifications.</p><h2 id="Classification-of-ODEs"><a class="docs-heading-anchor" href="#Classification-of-ODEs">Classification of ODEs</a><a id="Classification-of-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-ODEs" title="Permalink"></a></h2><p>We define a few nonlinearity types based on the expression of the residual.</p><ul><li><strong>Nonlinear</strong>. Nothing special can be said about the residual.</li><li><strong>Quasilinear</strong>. The residual is linear with respect to the highest-order time derivative and the corresponding linear form may depend on time and lower-order time derivatives, i.e. <span>$\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{M}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}) \partial_{t}^{n} \boldsymbol{u} + \boldsymbol{f}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).$</span> We call the matrix <span>$\boldsymbol{M}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> the mass matrix. In particular, a quasilinear ODE is a nonlinear ODE.</li><li><strong>Semilinear</strong>. The residual is quasilinear and the mass matrix may only depend on time, i.e. <span>$\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{M}(t) \partial_{t}^{n} \boldsymbol{u} + \boldsymbol{f}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).$</span> In particular, a semilinear ODE is a quasilinear ODE.</li><li><strong>Linear</strong>. The residual is linear with respect to all time derivatives, i.e. <span>$\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \sum_{0 \leq k \leq n} \boldsymbol{A}\_{k}(t) \partial_{t}^{k} \boldsymbol{u} + \boldsymbol{f}(t).$</span> We refer to the matrix <span>$\boldsymbol{A}\_{k}: \mathbb{R} \to \mathbb{R}^{d \times d}$</span> as the <span>$k$</span>-th linear form of the residual. We may still define the mass matrix <span>$\boldsymbol{M} = \boldsymbol{A}_{n}$</span>. In particular, a linear ODE is a semilinear ODE.</li></ul><blockquote><p>Note that for residuals of order zero (i.e. &quot;standard&quot; systems of equations), the definitions of quasilinear, semilinear, and linear coincide.</p></blockquote><p>We consider an extra ODE type that is motivated by stiff problems. We say that an ODE has an implicit-explicit (IMEX) decomposition if it be can written as the sum of a residual of order <span>$n$</span> and another residual of order <span>$n-1$</span>, i.e. <span>$\boldsymbol{r}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) = \boldsymbol{r}\_{\text{implicit}}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n} \boldsymbol{u}) + \boldsymbol{r}\_{\text{explicit}}(t, \partial_{t}^{0} \boldsymbol{u}, \ldots, \partial_{t}^{n-1} \boldsymbol{u}).$</span> The decomposition takes the form above so that the mass matrix of the global residual is fully contained in the implicit part. The table below indicates the type of the corresponding global ODE.</p><table><tr><th style="text-align: right">Explicit \ Implicit</th><th style="text-align: right">Nonlinear</th><th style="text-align: right">Quasilinear</th><th style="text-align: right">Semilinear</th><th style="text-align: right">Linear</th></tr><tr><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Quasilinear</td><td style="text-align: right">Semilinear</td><td style="text-align: right">Semilinear</td></tr><tr><td style="text-align: right">Linear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Quasilinear</td><td style="text-align: right">Semilinear</td><td style="text-align: right">Linear</td></tr></table><p>In particular, for the global residual to be linear, both the implicit and explicit parts need to be linear too.</p><blockquote><p>In the special case where the implicit part is linear and the explicit part is quasilinear or semilinear, we could, in theory, identify two linear forms for the global residual. However, introducing this difference would call for an order-dependent classification of ODEs and this would create (infinitely) many new types. Since numerical schemes can rarely take advantage of this extra structure in practice, we still say that the global residual is semilinear in these cases.</p></blockquote><h2 id="Classification-of-numerical-schemes"><a class="docs-heading-anchor" href="#Classification-of-numerical-schemes">Classification of numerical schemes</a><a id="Classification-of-numerical-schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-numerical-schemes" title="Permalink"></a></h2><p>We introduce a classification of numerical schemes based on where they evaluate the residual during the state update.</p><ul><li>If it is possible (up to a change of variables) to write the system of equations for the state update as evaluations of the residual at known values (that depend on the solution at the current time) for all but the highest-order derivative, we say that the scheme is explicit.</li><li>Otherwise, we say that the scheme is implicit.</li></ul><blockquote><p>For example, when solving a first-order ODE, the state update would involve solving one or more equations of the type <span>$\boldsymbol{r}(t_{k}, \boldsymbol{u}\_{k}(\boldsymbol{x}), \boldsymbol{v}\_{k}(\boldsymbol{x})) = \boldsymbol{0},$</span> where <span>$\boldsymbol{x}$</span> and the unknown of the state update. The scheme is explicit if it is possible to introduce a change of variables such that <span>$\boldsymbol{u}_{k}$</span> does not depend on <span>$\boldsymbol{x}$</span>. Otherwise, it is implicit.</p></blockquote><h2 id="Classification-of-systems-of-equations"><a class="docs-heading-anchor" href="#Classification-of-systems-of-equations">Classification of systems of equations</a><a id="Classification-of-systems-of-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Classification-of-systems-of-equations" title="Permalink"></a></h2><p>It is advantageous to introduce this classification of ODE and numerical schemes because the system of equations arising from the discretisation of the ODE by a numerical scheme will be linear or nonlinear depending on whether the scheme is explicit, implicit, or implicit-explicit, and on the type of the ODE. More precisely, we have the following table.</p><table><tr><th style="text-align: right"></th><th style="text-align: right">Nonlinear</th><th style="text-align: right">Quasilinear</th><th style="text-align: right">Semilinear</th><th style="text-align: right">Linear</th></tr><tr><td style="text-align: right">Explicit</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Linear</td><td style="text-align: right">Linear</td><td style="text-align: right">Linear</td></tr><tr><td style="text-align: right">Implicit</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Nonlinear</td><td style="text-align: right">Linear</td></tr></table><p>When the system is linear, another important practical consideration is whether the matrix of the system is constant across iterations or not. This is important because a linear solver typically performs a factorisation of the matrix, and this operation may only be performed once if the matrix is constant.</p><ul><li>If the linear system comes from an explicit scheme, the matrix of the system is constant if the mass matrix is. This means that the ODE has to be quasilinear.</li><li>If the linear system comes from an implicit scheme, all the linear forms must be constant for the system to have a constant matrix.</li></ul><h2 id="Reuse-across-iterations"><a class="docs-heading-anchor" href="#Reuse-across-iterations">Reuse across iterations</a><a id="Reuse-across-iterations-1"></a><a class="docs-heading-anchor-permalink" href="#Reuse-across-iterations" title="Permalink"></a></h2><p>For performance reasons, it is thus important that the ODE be described in the most specific way. In particular, we consider that the mass term of a quasilinear ODE is not constant, because if it is, the ODE is semilinear. We enable the user to specify the following constant annotations:</p><ul><li>For nonlinear and quasilinear ODE, no quantity can be described as constant.</li><li>For a semilinear ODE, whether the mass term is constant.</li><li>For a linear ODE, whether all the linear forms are constant.</li></ul><p>If a linear form is constant, regardless of whether the numerical scheme relies on a linear or nonlinear system, it is always possible to compute the jacobian of the residual with respect to the corresponding time derivative only once and retrieve it in subsequent computations of the jacobian.</p><h1 id="High-level-API-in-Gridap"><a class="docs-heading-anchor" href="#High-level-API-in-Gridap">High-level API in Gridap</a><a id="High-level-API-in-Gridap-1"></a><a class="docs-heading-anchor-permalink" href="#High-level-API-in-Gridap" title="Permalink"></a></h1><p>The ODE module of <code>Gridap</code> relies on the following structure.</p><h2 id="Finite-element-spaces"><a class="docs-heading-anchor" href="#Finite-element-spaces">Finite element spaces</a><a id="Finite-element-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-spaces" title="Permalink"></a></h2><p>The time-dependent counterpart of <code>TrialFESpace</code> is <code>TransientTrialFESpace</code>. It is built from a standard <code>TestFESpace</code> and is equipped with time-dependent Dirichlet boundary conditions.</p><blockquote><p>By definition, test spaces have zero boundary conditions so they need not be seen as time-dependent objects.</p></blockquote><p>A <code>TransientTrialFESpace</code> can be evaluated at any time derivative order, and the corresponding Dirichlet values are the time derivatives of the Dirichlet boundary conditions.</p><p>For example, the following creates a transient <code>FESpace</code> and evaluates its first two time derivatives.</p><pre><code class="language-none">g(t) = x -&gt; x[1] + x[2] * t
V = FESpace(model, reffe, dirichlet_tags=&quot;boundary&quot;)
U = TransientTrialFESpace (V, g)

t0 = 0.0
U0 = U(t0)

∂tU = ∂t(U)
∂tU0 = ∂tU(t0)

∂ttU = ∂tt(U) # or ∂ttU = ∂t(∂t(U))
∂ttU0 = ∂ttU(t0)</code></pre><h2 id="Cell-fields"><a class="docs-heading-anchor" href="#Cell-fields">Cell fields</a><a id="Cell-fields-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-fields" title="Permalink"></a></h2><p>The time-dependent equivalent of <code>CellField</code> is <code>TransientCellField</code>. It stores the cell field itself together with its derivatives up to the order of the ODE.</p><p>For example, the following creates a <code>TransientCellField</code> with two time derivatives.</p><pre><code class="language-none">u0 = zero(get_free_dof_values(U0))
∂tu0 = zero(get_free_dof_values(∂tU0))
∂ttu0 = zero(get_free_dof_values(∂ttU0))
u = TransientCellField(u0, (∂tu0, ∂ttu0))</code></pre><h2 id="Finite-element-operators"><a class="docs-heading-anchor" href="#Finite-element-operators">Finite element operators</a><a id="Finite-element-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-operators" title="Permalink"></a></h2><p>The time-dependent analog of <code>FEOperator</code> is <code>TransientFEOperator</code>. It has the following constructors based on the nonlinearity type of the underlying ODE.</p><ul><li><code>TransientFEOperator(res, jacs, trial, test)</code> and <code>TransientFEOperator(res, trial, test; order)</code> for the version with automatic jacobians. The residual is expected to have the signature <code>residual(t, u, v)</code>.</li><li><code>TransientQuasilinearFEOperator(mass, res, jacs, trial, test)</code> and <code>TransientQuasilinearFEOperator(mass, res, trial, test; order)</code> for the version with automatic jacobians. The mass and residual are expected to have the signatures <code>mass(t, u, dtNu, v)</code> and <code>residual(t, u, v)</code>, i.e. the mass is written as a linear form of the highest-order time derivative <code>dtNu</code>. In this setting, the mass matrix is supposed to depend on lower-order time derivatives, so <code>u</code> is provided for the nonlinearity of the mass matrix.</li><li><code>TransientSemilinearFEOperator(mass, res, jacs, trial, test; constant_mass)</code> and <code>TransientSemilinearFEOperator(mass, res, trial, test; order, constant_mass)</code> for the version with automatic jacobians. (The jacobian with respect to <span>$\partial_{t}^{n} \boldsymbol{u}$</span> is simply the mass term). The mass and residual are expected to have the signatures <code>mass(t, dtNu, v)</code> and <code>residual(t, u, v)</code>, where here again <code>dtNu</code> is the highest-order derivative. In particular, the mass is specified as a linear form of <code>dtNu</code>.</li><li><code>TransientLinearFEOperator(forms, res, jacs, trial, test; constant_forms)</code> and <code>TransientLinearFEOperator(forms, res, trial, test; constant_forms)</code> for the version with automatic jacobians. (In fact, the jacobians are simply the forms themselves). The forms and residual are expected to have the signatures <code>form_k(t, dtku, v)</code> and <code>residual(t, v)</code>, i.e. <code>form_k</code> is a linear form of the <span>$k$</span>-th order derivative, and the residual does not depend on <code>u</code>.</li></ul><p>It is important to note that all the terms are gathered in the residual, including the forcing term. In the common case where the forcing term is on the right-hand side, it will need to be made negative in this description.</p><p>Here, in the signature of the residual, <code>t</code> is the time at which the residual is evaluated, <code>u</code> is a function in the trial space, and <code>v</code> is a test function. Time derivatives of <code>u</code> can be included in the residual via the <code>∂t</code> operator, applied as many times as needed, or using the shortcut <code>∂t(u, N)</code>.</p><p>Let us take the heat equation as an example. The original ODE is <span>$\partial_{t} u - \nabla \cdot (\kappa(t) \nabla u) = f(t),$</span> where <span>$\kappa$</span> is the (time-dependent) thermal conductivity and <span>$f$</span> is the forcing term. We readily obtain the weak form <span>$\int_{\Omega} (\partial_{t} u) v + \kappa(t) \nabla u \cdot \nabla v \ \mathrm{d} \Omega = \int_{\Omega} f(t) v \ \mathrm{d} \Omega.$</span> It could be described as follows.</p><ul><li>As a <code>TransientFEOperator</code>:</li></ul><pre><code class="language-none">res(t, u, v) = ∫( ∂t(u) ⋅ v + (κ(t) * ∇(u)) ⋅ ∇(v) - f(t) ⋅ v ) * dΩ
TransientFEOperator(res, U, V)</code></pre><ul><li>As a <code>TransientQuasilinearFEOperator</code>:</li></ul><pre><code class="language-none">mass(t, u, dtNu, v) = ∫( dtNu ⋅ v ) * dΩ
res(t, u, v) = ∫( (κ(t) * ∇(u)) ⋅ ∇(v) - f(t) ⋅ v ) * dΩ
TransientQuasilinearFEOperator(mass, res, U, V)</code></pre><ul><li>As a <code>TransientSemilinearFEOperator</code>:</li></ul><pre><code class="language-none">mass(t, dtu, v) = ∫( dtu ⋅ v ) * dΩ
res(t, u, v) = ∫( (κ(t) * ∇(u)) ⋅ ∇(v) - f(t) ⋅ v ) * dΩ
TransientSemilinearFEOperator(mass, res, U, V, constant_mass=true)</code></pre><ul><li>As a <code>TransientLinearFEOperator</code>:</li></ul><pre><code class="language-none">stiffness(t, u, v) = ∫( (κ(t) * ∇(u)) ⋅ ∇(v) ) * dΩ
mass(t, dtu, v) = ∫( dtu ⋅ v ) * dΩ
res(t, u, v) = ∫( -f(t) ⋅ v ) * dΩ
TransientLinearFEOperator((stiffness, mass), res, U, V, constant_forms=(false, true))</code></pre><p>If <span>$\kappa$</span> is constant, the keyword <code>constant_forms</code> could be replaced by <code>(true, true)</code>.</p><h2 id="The-TimeSpaceFunction-constructor"><a class="docs-heading-anchor" href="#The-TimeSpaceFunction-constructor">The <code>TimeSpaceFunction</code> constructor</a><a id="The-TimeSpaceFunction-constructor-1"></a><a class="docs-heading-anchor-permalink" href="#The-TimeSpaceFunction-constructor" title="Permalink"></a></h2><p>Apply differential operators on a function that depends on time and space is somewhat cumbersome. Let <code>f</code> be a function of time and space, and <code>g(t) = x -&gt; f(t, x)</code> (as in the prescription of the boundary conditions <code>g</code> above). Applying the operator <span>$\partial_{t} - \Delta$</span>  to <code>g</code> and evaluating at <span>$(t, x)$</span> is written <code>∂t(g)(t)(x) - Δ(g(t))(x)</code>.</p><p>The constructor <code>TimeSpaceFunction</code> allows for simpler notations: let <code>h = TimeSpaceFunction(g)</code>. The object <code>h</code> is a functor that supports the notations </p><ul><li><code>op(h)</code>: a <code>TimeSpaceFunction</code> representing both <code>t -&gt; x -&gt; op(f)(t, x)</code> and <code>(t, x) -&gt; op(f)(t, x)</code>,</li><li><code>op(h)(t)</code>: a function of space representing <code>x -&gt; op(f)(t, x)</code></li><li><code>op(h)(t, x)</code>: the quantity <code>op(f)(t, x)</code> (this notation is equivalent to <code>op(h)(t)(x)</code>),</li></ul><p>for all spatial and temporal differential operator, i.e. <code>op</code> in <code>(time_derivative, gradient, symmetric_gradient, divergence, curl, laplacian)</code> and their symbolic aliases (<code>∂t</code>, <code>∂tt</code>, <code>∇</code>, ...). The operator above applied to <code>h</code> and evaluated at <code>(t, x)</code> can be conveniently written <code>∂t(h)(t, x) - Δ(h)(t, x)</code>.</p><h2 id="Solver-and-solution"><a class="docs-heading-anchor" href="#Solver-and-solution">Solver and solution</a><a id="Solver-and-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-and-solution" title="Permalink"></a></h2><p>The next step is to choose an ODE solver (see below for a full list) and specify the boundary conditions. The solution can then be iterated over until the final time is reached.</p><p>For example, to use the <span>$\theta$</span>-method with a nonlinear solver, one could write</p><pre><code class="language-none">t0 = 0.0
tF = 1.0
dt = 0.1
uh0 = interpolate_everywhere(t0, U(t0))

res(t, u, v) = ∫( ∂t(u) ⋅ v + (κ(t) * ∇(u)) ⋅ ∇(v) - f(t) ⋅ v ) * dΩ
jac(t, u, du, v) = ∫( (κ(t) * ∇(du)) ⋅ ∇(v) ) * dΩ
jac_t(t, u, dtu, v) = ∫( dtu ⋅ v ) * dΩ
tfeop = TransientFEOperator(res, (jac, jac_t), U, V)

ls = LUSolver()
nls = NLSolver(ls, show_trace=true, method=:newton, iterations=10)
odeslvr = ThetaMethod(nls, dt, 0.5)

sol = solve(odeslvr, tfeop, t0, tF, uh0)
for (tn, un) in enumerate(sol)
    # ...
end</code></pre><h1 id="Low-level-implementation"><a class="docs-heading-anchor" href="#Low-level-implementation">Low-level implementation</a><a id="Low-level-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-implementation" title="Permalink"></a></h1><p>We now briefly describe the low-level implementation of the ODE module in <code>Gridap</code>.</p><h2 id="ODE-operators"><a class="docs-heading-anchor" href="#ODE-operators">ODE operators</a><a id="ODE-operators-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-operators" title="Permalink"></a></h2><p>The <code>ODEOperator</code> type represents an ODE according to the description above. It implements the <code>NonlinearOperator</code> interface, which enables the computation of residuals and jacobians.</p><p>The algebraic equivalent of <code>TransientFEOperator</code> is an <code>ODEOpFromTFEOp</code>, which is a subtype of <code>ODEOperator</code>. Conceptually, <code>ODEOpFromTFEOp</code> can be thought of as an assembled <code>TransientFEOperator</code>, i.e. it deals with vectors of degrees of freedom. This operator comes with a cache (<code>ODEOpFromTFEOpCache</code>) that stores the transient space, its evaluation at the current time step, a cache for the <code>TransientFEOperator</code> itself (if any), and the constant forms (if any).</p><blockquote><p>For now <code>TransientFEOperator</code> does not implement the <code>FEOperator</code> interface, i.e. it is not possible to evaluate residuals and jacobians directly on it. Rather, they are meant to be evaluated on the <code>ODEOpFromFEOp</code>. This is to cut down on the number of conversions between a <code>TransientCellField</code> and its vectors of degrees of freedom (one per time derivative). Indeed, when linear forms are constant, no conversion is needed as the jacobian matrix will be stored.</p></blockquote><h2 id="ODE-solvers"><a class="docs-heading-anchor" href="#ODE-solvers">ODE solvers</a><a id="ODE-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-solvers" title="Permalink"></a></h2><p>An ODE solver has to implement the following interface.</p><ul><li><code>allocate_odecache(odeslvr, odeop, t0, us0)</code>. This function allocates a cache that can be reused across the three functions <code>ode_start</code>, <code>ode_march!</code>, and <code>ode_finish!</code>. In particular, it is necessary to call <code>allocate_odeopcache</code> within this function, so as to instantiate the <code>ODEOpFromTFEOpCache</code> and be able to update the Dirichlet boundary conditions in the subsequent functions.</li><li><code>ode_start(odeslvr, odeop, t0, us0, odecache)</code>. This function creates the state vectors from the initial conditions. By default, this is the identity.</li><li><code>ode_march!(stateF, odeslvr, odeop, t0, state0, odecache)</code>. This is the update map that evolves the state vectors.</li><li><code>ode_finish!(uF, odeslvr, odeop, t0, tF, stateF, odecache)</code>. This function converts the state vectors into the evaluation of the solution at the current time step. By default, this copies the first state vector into <code>uF</code>.</li></ul><h2 id="Stage-operator"><a class="docs-heading-anchor" href="#Stage-operator">Stage operator</a><a id="Stage-operator-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-operator" title="Permalink"></a></h2><p>A <code>StageOperator</code> represents the linear or nonlinear operator that a numerical scheme relies on to evolve the state vector. It is essentially a special kind of <code>NonlinearOperator</code> but it overwrites the behaviour of nonlinear and linear solvers to take advantage of the matrix of a linear system being constant. The following subtypes of <code>StageOperator</code> are the building blocks of all numerical schemes.</p><ul><li><code>LinearStageOperator</code> represents the system <span>$\boldsymbol{J} \boldsymbol{x} + \boldsymbol{r} = \boldsymbol{0}$</span>, and can build <span>$\boldsymbol{J}$</span> and <span>$\boldsymbol{r}$</span> by evaluating the residual at a given point.</li><li><code>NonlinearStageOperator</code> represents <span>$\boldsymbol{r}(\boldsymbol{t}, \boldsymbol{\ell}\_{0}(\boldsymbol{x}), \ldots, \boldsymbol{\ell}\_{N}(\boldsymbol{x})) = \boldsymbol{0}$</span>, where it is assumed that all the <span>$\boldsymbol{\ell}_{k}(\boldsymbol{x})$</span> are linear in <span>$\boldsymbol{x}$</span>.</li></ul><h2 id="ODE-solution"><a class="docs-heading-anchor" href="#ODE-solution">ODE solution</a><a id="ODE-solution-1"></a><a class="docs-heading-anchor-permalink" href="#ODE-solution" title="Permalink"></a></h2><p>This type is a simple wrapper around an <code>ODEOperator</code>, an <code>ODESolver</code>, and initial conditions that can be iterated on to evolve the ODE.</p><h1 id="Numerical-schemes-formulation-and-implementation"><a class="docs-heading-anchor" href="#Numerical-schemes-formulation-and-implementation">Numerical schemes formulation and implementation</a><a id="Numerical-schemes-formulation-and-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-schemes-formulation-and-implementation" title="Permalink"></a></h1><p>We conclude this note by describing some numerical schemes and their implementation in <code>Gridap</code>.</p><p>Suppose that the scheme has been evolved up to time <span>$t_{n}$</span> already and that the state vectors <span>$\\{\boldsymbol{s}\\}\_{n}$</span> are known. We are willing to evolve the ODE up to time <span>$t_{n+1} &gt; t_{n}$</span>, i.e. compute the state vectors <span>$\\{\boldsymbol{s}\\}\_{n+1}$</span>. Generally speaking, a numerical scheme constructs an approximation of the map <span>$\\{\boldsymbol{s}\\}\_{n} \to \\{\boldsymbol{s}\\}\_{n+1}$</span> by solving one or more relationships of the type <span>$\boldsymbol{r}(t_{i}, \Delta_{i}^{0}(\\{\boldsymbol{s}\\}\_{n}, \\{\boldsymbol{s}\\}\_{n+1}), \ldots, \Delta_{i}^{n}(\\{\boldsymbol{s}\\}\_{n}, \\{\boldsymbol{s}\\}\_{n+1})) = \boldsymbol{0},$</span> where <span>$t_{i}$</span> is an intermediate time and <span>$\Delta_{i}^{k}$</span> are discrete operators that approximates the <span>$k$</span>-th order time derivative of <span>$\boldsymbol{u}$</span> at time <span>$t_{i}$</span>.</p><p>We now describe the numerical schemes implemented in <code>Gridap</code> using this framework. It is usually convenient to perform a change of variables so that the unknown <span>$\boldsymbol{x}$</span> has the dimension of the highest-order time derivative of <span>$\boldsymbol{u}$</span>, i.e. <span>$[\boldsymbol{x}] = [t]^{-n} [\boldsymbol{u}]$</span> (where <span>$[\bullet]$</span> stands for &quot;the dimension of <span>$\bullet$</span>&quot;). We always perform such a change of variable in practice.</p><p>We also briefly characterise these schemes in terms of their order and linear stability.</p><h2 id="\\theta-method"><a class="docs-heading-anchor" href="#\\theta-method"><span>$\theta$</span>-method</a><a id="\\theta-method-1"></a><a class="docs-heading-anchor-permalink" href="#\\theta-method" title="Permalink"></a></h2><p>This scheme is used to solve first-order ODEs and relies on the simple state vector <span>$\\{\boldsymbol{s}(t)\\} = \\{\boldsymbol{u}(t)\\}$</span>. This means that the starting and finishing procedures are simply the identity.</p><p>The <span>$\theta$</span>-method relies on the following approximation <span>$\boldsymbol{u}(t_{n+1}) = \boldsymbol{u}(t_{n}) + \int_{t_{n}}^{t_{n+1}} \partial_{t} \boldsymbol{u}(t) \ \mathrm{d} t \approx \boldsymbol{u}(t_{n}) + h_{n} \partial_{t} \boldsymbol{u}(t_{n + \theta}),$</span> where we have introduced the intermediate time <span>$t_{n + \theta} \doteq (1 - \theta) t_{n} + \theta t_{n+1}$</span>. By replacing <span>$\boldsymbol{u}(t_{n})$</span> and <span>$\boldsymbol{u}(t_{n+1})$</span> by their discrete equivalents, we have <span>$\partial_{t} \boldsymbol{u}(t_{n + \theta}) \approx \frac{1}{h} (\boldsymbol{u}\_{n+1} - \boldsymbol{u}\_{n})$</span>. This quantity is found by enforcing that the residual is zero at <span>$t_{n + \theta}$</span>. In that sense, the <span>$\theta$</span>-method can be framed as a collocation method at <span>$t_{n + \theta}$</span>. For that purpose, we use the same quadrature rule as above to approximate <span>$\boldsymbol{u}(t_{n + \theta})$</span>, i.e. <span>$\boldsymbol{u}(t_{n + \theta}) \approx \boldsymbol{u}\_{n} + \theta h\_{n} \partial_{t} \boldsymbol{u}(t_{n + \theta})$</span>. Using the notations of the framework above, we have defined</p><p class="math-container">\[\begin{align*}
t_{1} &amp;= (1 - \theta) t_{n} + \theta t_{n+1}, \\
\Delta_{1}^{0} &amp;= (1 - \theta) \boldsymbol{u}_{n} + \theta \boldsymbol{u}_{n+1}, \\
\Delta_{1}^{1} &amp;= \frac{1}{h} (\boldsymbol{u}_{n+1} - \boldsymbol{u}_{n}).
\end{align*}\]</p><p>To summarize and to be more concrete, let <span>$\boldsymbol{x} = \frac{1}{h} (\boldsymbol{u}\_{n+1} - \boldsymbol{u}\_{n})$</span>. The <span>$\theta$</span>-method solves the following stage operator <span>$\boldsymbol{r}(t_{n} + \theta h_{n}, \boldsymbol{u}\_{n} + \theta h_{n} \boldsymbol{x}, \boldsymbol{x}) = \boldsymbol{0},$</span> and sets <span>$\boldsymbol{u}\_{n+1} = \boldsymbol{u}\_{n} + h_{n} \boldsymbol{x}$</span>. The output state is simply <span>$\\{\boldsymbol{s}\\}\_{n+1} = \\{\boldsymbol{u}_{n+1}\\}$</span>.</p><p><strong>Analysis</strong> Since this scheme uses <span>$\boldsymbol{u}(t)$</span> as its only state vector, the amplification matrix has dimension one, and its coefficient is the stabilisation function, given by <span>$\rho(z) = \frac{1 + (1 - \theta) z}{1 - \theta z}.$</span> We plug the Taylor expansion of <span>$\boldsymbol{u}\_{n+1}$</span> around <span>$\boldsymbol{u}\_{n}$</span> in <span>$\boldsymbol{u}\_{n+1} = \rho(z) \boldsymbol{u}\_{n}$</span> and obtain the exactness condition <span>$\rho(z) - \exp(z) = 0$</span>. We then seek to match as many coefficients in the Taylor expansion of both sides to obtain order conditions. We readily obtain the following expansion <span>$\rho(z) - \exp(z) = \sum_{k \geq 0} \left[\theta^{k} - \frac{1}{(k+1)!}\right] z^{k+1}.$</span> The order conditions are as follows.</p><ul><li><strong>Order 0 and 1</strong>. The first two coefficients are always zero, so the method has at least order one.</li><li><strong>Order 2</strong>. The third coefficient is <span>$\theta - \frac{1}{2}$</span>, and it is zero when <span>$\theta = \frac{1}{2}$</span>. This value of <span>$\theta$</span> corresponds to a second-order scheme. The next coefficient is <span>$\theta^{2} - \frac{1}{6}$</span>, so this method cannot reach order three.</li></ul><p>By looking at the behaviour of the stability function at infinity, we find that the scheme is <span>$L$</span>-stable only when <span>$\theta = 1$</span>. We determine whether the scheme is <span>$A$</span>-stable or not by looking at stability region. We distinguish three cases based on the value of <span>$\theta$</span>.</p><ul><li><p class="math-container">\[\theta &lt; \frac{1}{2}\]</p>. The stability region is the circle of radius <span>$\frac{1}{1 - 2 \theta}$</span> centered at <span>$\left(\frac{-1}{1 - 2 \theta}, 0\right)$</span>. In particular, it is not <span>$A$</span>-stable. The special case <span>$\theta = 0$</span> is known as the Forward Euler scheme, which is the only explicit scheme of the <span>$\theta$</span>-method family.</li><li><p class="math-container">\[\theta = \frac{1}{2}\]</p>. The stability region is the whole left complex plane, so the scheme is <span>$A$</span>-stable. This case is known as the implicit midpoint scheme. </li><li><p class="math-container">\[\theta &gt; \frac{1}{2}\]</p>. The stability region is the whole complex plane except the circle of radius <span>$\frac{1}{2 \theta - 1}$</span> centered at <span>$\left(\frac{1}{2 \theta - 1}, 0\right)$</span>. In particular, the scheme is <span>$A$</span>-stable. The special case <span>$\theta = 1$</span> is known as the Backward Euler scheme. </li></ul><h2 id="Generalised-\\alpha-scheme-for-first-order-ODEs"><a class="docs-heading-anchor" href="#Generalised-\\alpha-scheme-for-first-order-ODEs">Generalised- <span>$\alpha$</span> scheme for first-order ODEs</a><a id="Generalised-\\alpha-scheme-for-first-order-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Generalised-\\alpha-scheme-for-first-order-ODEs" title="Permalink"></a></h2><p>This scheme relies on the state vector <span>$\\{\boldsymbol{s}(t)\\} = \\{\boldsymbol{u}(t), \partial_{t} \boldsymbol{u}(t)\\}$</span>. In particular, it needs a nontrivial starting procedure that evaluates <span>$\partial_{t} \boldsymbol{u}(t_{0})$</span> by enforcing a zero residual at <span>$t_{0}$</span>. The finaliser can still return the first vector of the state vectors. For convenience, let <span>$\partial_{t} \boldsymbol{u}\_{n}$</span> denote the approximation <span>$\partial_{t} \boldsymbol{u}(t_{n})$</span>.</p><blockquote><p>Alternatively, the initial velocity can be provided manually: when calling <code>solve(odeslvr, tfeop, t0, tF, uhs0)</code>, set <code>uhs0 = (u0, v0, a0)</code> instead of <code>uhs0 = (u0, v0)</code>. This is useful when enforcing a zero initial residual would lead to a singular system.</p></blockquote><p>This method extends the <span>$\theta$</span>-method by considering the two-point quadrature rule <span>$\boldsymbol{u}(t_{n+1}) = \boldsymbol{u}\_{n} + \int_{t_{n}}^{t_{n+1}} \partial_{t} \boldsymbol{u}(t) \ \mathrm{d} t \approx \boldsymbol{u}\_{n} + h_{n} [(1 - \gamma) \partial_{t} \boldsymbol{u}(t_{n}) + \gamma \partial_{t} \boldsymbol{u}(t_{n+1})],$</span> where <span>$0 \leq \gamma \leq 1$</span> is a free parameter. The question is now how to estimate <span>$\partial_{t} \boldsymbol{u}(t_{n+1})$</span>. This is achieved by enforcing a zero residual at <span>$t_{n + \alpha_{F}} \doteq (1 - \alpha_{F}) t_{n} + \alpha_{F} t_{n+1}$</span>, where <span>$0 \leq \alpha_{F} \leq 1$</span> is another free parameter. The value of <span>$\boldsymbol{u}$</span> at that time, <span>$\boldsymbol{u}\_{n + \alpha_{F}}$</span>, is obtained by the same linear combination of <span>$\boldsymbol{u}$</span> at <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. Regarding <span>$\partial_{t} \boldsymbol{u}$</span>, it is taken as a linear combination weighted by another free parameter <span>$0 &lt; \alpha_{M} \leq 1$</span> of the time derivative at times <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. Note that <span>$\alpha_{M}$</span> cannot be zero. Altogether, we have defined the discrete operators</p><p class="math-container">\[\begin{align*}
t_{1} &amp;= (1 - \alpha_{F}) t_{n} +  \alpha_{F} t_{n+1}, \\
\Delta_{1}^{0} &amp;= (1 - \alpha_{F}) \boldsymbol{u}_{n} + \alpha_{F} \boldsymbol{u}_{n+1}, \\
\Delta_{1}^{1} &amp;= (1 - \alpha_{M}) \partial_{t} \boldsymbol{u}_{n} + \alpha_{M} \partial_{t} \boldsymbol{u}_{n+1}.
\end{align*}\]</p><p>In more concrete terms, we solve the following system:</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n + \alpha_{F}}, \boldsymbol{u}_{n + \alpha_{F}}, \partial_{t} \boldsymbol{u}_{n + \alpha_{M}}), \\
t_{n + \alpha_{F}} &amp;= (1 - \alpha_{F}) t_{n} + \alpha_{F} t_{n+1}, \\
\boldsymbol{u}_{n + \alpha_{F}} &amp;= (1 - \alpha_{F}) \boldsymbol{u}_{n} + \alpha_{F} \boldsymbol{u}_{n+1}, \\
\partial_{t} \boldsymbol{u}_{n + \alpha_{M}} &amp;= (1 - \alpha_{M}) \partial_{t} \boldsymbol{u}_{n} + \alpha_{M} \partial_{t} \boldsymbol{u}_{n+1}, \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + h_{n} [(1 - \gamma) \partial_{t} \boldsymbol{u}_{n} + \gamma \boldsymbol{x}], \\
\partial_{t} \boldsymbol{u}_{n+1} &amp;= \boldsymbol{x}.
\end{align*}\]</p><p>The state vector is updated to <span>$\\{\boldsymbol{s}\\}\_{n+1} = \\{\boldsymbol{u}\_{n+1}, \partial_{t} \boldsymbol{u}_{n+1}\\}$</span>.</p><p><strong>Analysis</strong> The amplification matrix for the state vector is</p><p class="math-container">\[\boldsymbol{A}(z) = \frac{1}{\alpha_{M} - \alpha_{F} \gamma z} \begin{bmatrix}\alpha_{M} + (1 - \alpha_{F}) \gamma z &amp; \alpha_{M} - \gamma \\ z &amp; \alpha_{M} - 1 + \alpha_{F} (1 - \gamma) z\end{bmatrix}.\]</p><p>It is then immediate to see that <span>$\boldsymbol{u}\_{n+1} = \mathrm{tr}(\boldsymbol{A}) \boldsymbol{u}\_{n} - \det(\boldsymbol{A}) \boldsymbol{u}\_{n-1}$</span>. This time, plugging the Taylor expansion of <span>$\boldsymbol{u}\_{n+1}$</span> and <span>$\boldsymbol{u}\_{n-1}$</span> around <span>$\boldsymbol{u}\_{n}$</span> in this expression, the exactness condition is <span>$\mathrm{tr}(\boldsymbol{A}(z)) - \det(\boldsymbol{A}(z)) \exp(-z) - \exp(z) = 0$</span>. To simplify the analysis, we write the trace and determinant of <span>$\boldsymbol{A}$</span> as follows <span>$\mathrm{tr}(\boldsymbol{A}(z)) = a + \frac{b}{1 - c z}, \qquad \det(\boldsymbol{A}(z)) = d + \frac{e}{1 - c z},$</span> where</p><p class="math-container">\[\begin{align*}
a &amp;= 2 - \frac{1}{\alpha_{F}} - \frac{1}{\gamma}, \\
b &amp;= \frac{1}{\alpha_{F}} + \frac{1}{\gamma} - \frac{1}{\alpha_{M}}, \\
c &amp;= \frac{\alpha_{F} \gamma}{\alpha_{M}}, \\
d &amp;= \frac{(1 - \alpha_{F}) (1 - \gamma)}{\alpha_{F} \gamma}, \\
e &amp;= \frac{\alpha_{M} (\alpha_{F} + \gamma - 1) - \alpha_{F} \gamma}{\alpha_{F} \alpha_{M} \gamma}.
\end{align*}\]</p><p>Next, we obtain the Taylor expansion of the exactness condition and find <span>$(a + b - d - e - 1) + \sum_{k \geq 1} \left(b c^{k} - \frac{1}{k!} - \frac{(-1)^{k}}{k!} d - \sum_{0 \leq l \leq k} e c^{(k - l)}\frac{(-1)^{l}}{l!}\right) z^{k} = 0.$</span> The order conditions are as follows.</p><ul><li><strong>Order 0 and 1</strong>. The first two coefficients are always zero, so the method is at least of order <span>$2$</span>.</li><li><strong>Order 2</strong>. The third coefficient has a zero at <span>$\gamma = \frac{1}{2} + \alpha_{M} - \alpha_{F}$</span>.</li><li><strong>Order 3</strong>. The fourth coefficient has a zero at <span>$\alpha_{M} = \frac{1 + 6 \alpha_{F} - 12 \alpha_{F}^{2}}{6(1 - 2 \alpha_{F})}$</span> (provided that <span>$\alpha_{F} \neq \frac{1}{2}$</span>). In that case we simplify <span>$\gamma$</span> into <span>$\gamma = \frac{2 - 3 \alpha_{F}}{3(1 - 2 \alpha_{F})}$</span>.</li><li><strong>Order 4</strong>. The fifth coefficient has zeros at <span>$\alpha_{F} = \frac{3 \pm \sqrt{3}}{6}$</span> and poles at <span>$\alpha_{F} = \frac{3 \pm \sqrt{21}}{12}$</span>. The corresponding values of <span>$\alpha_{M}$</span> and <span>$\gamma$</span> are <span>$\alpha_{M} = \frac{1}{2}$</span>, <span>$\gamma = \frac{3 \mp \sqrt{3}}{6}$</span>.</li></ul><p>We finally study the stability in the extreme cases <span>$|z| \to 0$</span> and <span>$|z| \to +\infty$</span>. We want the spectral radius of the amplification matrix to be smaller than one so that perturbations are damped away.</p><ul><li>When <span>$|z| \to 0$</span>, we have <span>$\rho(\boldsymbol{A}(z)) \to \max\\{1, \left|1 - \frac{1}{\alpha_{M}}\right|\\}$</span>.</li><li>When <span>$|z| \to +\infty$</span>, we have <span>$\rho(\boldsymbol{A}(z)) \to \max\\{\left|1 - \frac{1}{\alpha_{F}}\right|, \left|1 - \frac{1}{\gamma}\right|\\}$</span>.</li></ul><p>We thus require <span>$\alpha_{M} \geq \frac{1}{2}$</span>, <span>$\alpha_{F} \geq \frac{1}{2}$</span> and <span>$\gamma \geq \frac{1}{2}$</span> to ensure stability. In particular when the scheme has order <span>$3$</span>, the stability conditions become <span>$\alpha_{M} \geq \alpha_{F} \geq \frac{1}{2}$</span>. We verify that the scheme is unstable whenever it has an order greater than <span>$3$</span>. We notice that <span>$L$</span>-stability is only achieved when <span>$\alpha_{F} = 1$</span> and <span>$\gamma = 1$</span>. The corresponding value of <span>$\alpha_{M}$</span> for a third-order scheme is <span>$\alpha_{M} = \frac{3}{2}$</span>.</p><p>This scheme was originally devised to control the damping of high frequencies. One parameterisation consists in prescribing the eigenvalues at <span>$|z| \to +\infty$</span>, and this leads to <span>$\alpha_{F} = \gamma = \frac{1}{1 + \rho_{\infty}}, \qquad \alpha_{M} = \frac{3 - \rho_{\infty}}{2 (1 + \rho_{\infty})},$</span> where <span>$\rho_{\infty}$</span> is the spectral radius at infinity. Setting <span>$\rho_{\infty}$</span> cuts all the highest frequencies in one step, whereas taking <span>$\rho_{\infty} = 1$</span> preserves high frequencies.</p><h2 id="Runge-Kutta"><a class="docs-heading-anchor" href="#Runge-Kutta">Runge-Kutta</a><a id="Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#Runge-Kutta" title="Permalink"></a></h2><p>Runge-Kutta methods are multi-stage, i.e. they build estimates of <span>$\boldsymbol{u}$</span> at intermediate times between <span>$t_{n}$</span> and <span>$t_{n+1}$</span>. They can be written as follows</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n} + c_{i} h_{n} , \boldsymbol{u}_{n} + \sum_{1 \leq j \leq s} a_{ij} h_{n} \boldsymbol{x}_{j}, \boldsymbol{x}_{i}), &amp; 1 \leq i \leq p \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + \sum_{1 \leq i \leq p} b_{i} h_{n} \boldsymbol{x}_{i},
\end{align*}\]</p><p>where <span>$p$</span> is the number of stages, <span>$\boldsymbol{A} = (a_{ij})\_{1 \leq i, j \leq p}$</span> is a matrix of free parameters, <span>$\boldsymbol{b} = (b_{i})\_{1 \leq i \leq p}$</span> and <span>$\boldsymbol{c} = (c_{i})\_{1 \leq i \leq p}$</span> are two vectors of free parameters. The stage unknowns <span>$(\boldsymbol{x}\_{i})_{1 \leq i \leq p}$</span> are involved in a coupled system of equations. This system can take a simpler form when the matrix <span>$\boldsymbol{A}$</span> has a particular structure.</p><ul><li>When <span>$\boldsymbol{A}$</span> is lower triangular, the equations are decoupled and can thus be solved sequentially. These schemes are called Diagonally-Implicit Runge-Kutta (DIRK). If the diagonal coefficients of the matrix <span>$\boldsymbol{A}$</span> are the same, the method is called Singly-Diagonally Implicit (SDIRK).</li><li>If the diagonal coefficients are also zero, the method is explicit. These schemes are called Explicit Runge-Kutta (EXRK).</li></ul><p><strong>Implementation details</strong> It is particularly advantageous to save the factorisation of the matrices of the stage operators for Runge-Kutta methods. This is always possible when the method is explicit and the mass matrix is constant, in which case all the stage matrices are the mass matrix. When the method is diagonally-implicit and the stiffness and mass matrices are constant, the matrices of the stage operators are <span>$\boldsymbol{M} + a_{ii} h_{n} \boldsymbol{K}$</span>. In particular, if two diagonal coefficients coincide, the corresponding operators will have the same matrix. We implement these reuse strategies by storing them in <code>CompressedArray</code>s, and introducing a map <code>i -&gt; NumericalSetup</code>.</p><p><strong>Analysis</strong> The stability function of a Runge-Kutta scheme is <span>$\rho(z) = 1 + z \boldsymbol{b}^{T} (\boldsymbol{I} - z \boldsymbol{A})^{-1} \boldsymbol{1}.$</span></p><p>The analysis of Runge-Kutta methods is well-established but we only derive order conditions for schemes with one, two, or three stages in the diagonally-implicit case.</p><ul><li><p><strong>One stage</strong>. These schemes coincide with the <span>$\theta$</span>-method presented above.</p></li><li><p><strong>Two stages</strong>. We solve the order conditions given by the differential trees and find the following families of tableaus of orders two and three</p></li></ul><p class="math-container">\[\begin{array}{c|cc}
\alpha &amp; \alpha &amp; \\
\beta &amp; \beta - \hat{\beta} &amp; \hat{\beta} \\ \hline
&amp; \frac{2 \beta - 1}{2 (\beta - \alpha)} &amp; \frac{1 - 2 \alpha}{2 (\beta - \alpha)}
\end{array}, \qquad
\begin{array}{c|cc}
\frac{1}{2} - \frac{\sqrt{3}}{6} \frac{1}{\lambda} &amp; \frac{1}{2} - \frac{\sqrt{3}}{6} \frac{1}{\lambda} &amp; \\
\frac{1}{2} + \frac{\sqrt{3}}{6} \lambda &amp; \frac{\sqrt{3}}{3} \lambda &amp; \frac{1}{2} - \frac{\sqrt{3}}{6} \lambda \\ \hline
&amp; \frac{\lambda^{2}}{\lambda^{2} + 1} &amp; \frac{1}{\lambda^{2} + 1}.
\end{array}\]</p><ul><li><strong>Three stages</strong>. We only solve the explicit schemes in full generality. We find three families of order three</li></ul><p class="math-container">\[\begin{array}{c|cc}
0 &amp; \\
\alpha &amp; \alpha &amp; \\
\beta &amp; \beta - \frac{\beta (\beta - \alpha)}{\alpha (2 - 3\alpha)} &amp; \frac{\beta (\beta - \alpha)}{ \alpha(2 - 3 \alpha)} \\ \hline
&amp; 1 - \frac{3 (\beta + \alpha) - 2}{6 \alpha \beta} &amp; \frac{3 \beta - 2}{6 \alpha (\beta - \alpha)} &amp; \frac{2 - 3 \alpha}{6 \beta (\beta - \alpha)}
\end{array}, \qquad
\begin{array}{c|cc}
0 &amp; \\
\frac{2}{3} &amp; \frac{2}{3} &amp; \\
\frac{2}{3} &amp; \frac{2}{3} - \frac{1}{4 \alpha} &amp; \frac{1}{4 \alpha} \\ \hline
&amp; \frac{1}{4} &amp; \frac{3}{4} - \alpha &amp; \alpha
\end{array}, \qquad
\begin{array}{c|cc}
0 &amp; \\
\frac{2}{3} &amp; \frac{2}{3} &amp; \\
0 &amp; -\frac{1}{4 \alpha} &amp; \frac{1}{4 \alpha} \\ \hline
&amp; \frac{1}{4} - \alpha &amp; \frac{3}{4} &amp; \alpha
\end{array}.\]</p><h2 id="Implicit-Explicit-Runge-Kutta"><a class="docs-heading-anchor" href="#Implicit-Explicit-Runge-Kutta">Implicit-Explicit Runge-Kutta</a><a id="Implicit-Explicit-Runge-Kutta-1"></a><a class="docs-heading-anchor-permalink" href="#Implicit-Explicit-Runge-Kutta" title="Permalink"></a></h2><p>When the residual has an implicit-explicit decomposition, usually because we can identify a stiff part that we want to solve implicitly and a nonstiff part that we want to solve explicitly, the Runge-Kutta method reads as follows</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n} + c_{i} h_{n}, \boldsymbol{u}_{n} + \sum_{1 \leq j \leq i-1} (a_{i, j} h_{n} \boldsymbol{x}_{j} + \hat{a}_{i, j} h_{n} \hat{\boldsymbol{x}}_{j}) + a_{i, i} h_{n} \boldsymbol{x}_{i}, \boldsymbol{x}_{i}), \\
\boldsymbol{0} &amp;= \hat{\boldsymbol{r}}(t_{n} + c_{i} h_{n}, \boldsymbol{u}_{n} + \sum_{1 \leq j \leq i-1} (a_{i, j} h_{n} \boldsymbol{x}_{j} + \hat{a}_{i, j} h_{n} \hat{\boldsymbol{x}}_{j}) + a_{i, i} h_{n} \boldsymbol{x}_{i}, \hat{\boldsymbol{x}}_{i}), &amp; 1 \leq i \leq p \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + \sum_{1 \leq i \leq p} (b_{i} h_{n} \boldsymbol{x}_{i} + \hat{b}_{i} h_{n} \hat{\boldsymbol{x}}_{i}).
\end{align*}\]</p><p>In these expressions, quantities that wear a hat are the explicit counterparts of the implicit quantity with the same name. The implicit and explicit stages are alternated, i.e. the implicit and explicit stage unknowns <span>$\boldsymbol{x}\_{i}$</span> and <span>$\hat{\boldsymbol{x}}\_{i}$</span> are solved alternatively. As seen above, we require that the nodes <span>$c_{i}$</span> of the implicit and explicit tableaus coincide. This implies that the first step for the implicit part is actually explicit.</p><p><strong>Implementation details</strong> Many methods can be created by padding a DIRK tableau with zeros to give it an additional step. In this case, the first stage for the implicit part does not need to be solved, as all linear combinations give it a zero weight. As an example, an <span>$L$</span>-stable, <span>$2$</span>-stage, second-order SDIRK IMEX scheme is given by</p><p class="math-container">\[\begin{array}{c|ccc}
0 &amp; 0 &amp; 0 &amp; 0 \\
\frac{2 - \sqrt{2}}{2} &amp; 0 &amp; \frac{2 - \sqrt{2}}{2} &amp; 0 \\
1 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2} \\ \hline
 &amp; 0 &amp; \frac{\sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2}
\end{array}, \qquad
\begin{array}{c|ccc}
0 &amp; 0 &amp; 0 &amp; 0 \\
\frac{2 - \sqrt{2}}{2} &amp; \frac{2 - \sqrt{2}}{2} &amp; 0 &amp; 0 \\
1 &amp; -\frac{\sqrt{2}}{2} &amp; 1 + \frac{\sqrt{2}}{2} &amp; 0 \\ \hline
 &amp; -\frac{\sqrt{2}}{2} &amp; 1 + \frac{\sqrt{2}}{2} &amp; 0
\end{array}.\]</p><p>We note that the first column of the matrix and the first weight are all zero, so the first stage for the implicit part does not need to be solved.</p><h2 id="Generalised-\\alpha-scheme-for-second-order-ODEs"><a class="docs-heading-anchor" href="#Generalised-\\alpha-scheme-for-second-order-ODEs">Generalised- <span>$\alpha$</span> scheme for second-order ODEs</a><a id="Generalised-\\alpha-scheme-for-second-order-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Generalised-\\alpha-scheme-for-second-order-ODEs" title="Permalink"></a></h2><p>This scheme relies on the state vector <span>$\\{\boldsymbol{s}(t)\\} = \\{\boldsymbol{u}(t), \partial_{t} \boldsymbol{u}(t), \partial_{tt} \boldsymbol{u}(t)\\}$</span>. It needs a nontrivial starting procedure that evaluates <span>$\partial_{tt} \boldsymbol{u}(t_{0})$</span> by enforcing a zero residual at <span>$t_{0}$</span>. The finaliser can still return the first vector of the state vectors. For convenience, let <span>$\partial_{tt} \boldsymbol{u}\_{n}$</span> denote the approximation <span>$\partial_{tt} \boldsymbol{u}(t_{n})$</span>.</p><blockquote><p>The initial acceleration can alternatively be provided manually: when calling <code>solve(odeslvr, tfeop, t0, tF, uhs0)</code>, set <code>uhs0 = (u0, v0, a0)</code> instead of <code>uhs0 = (u0, v0)</code>. This is useful when enforcing a zero initial residual would lead to a singular system.</p></blockquote><p>This method is built out of the following update rule</p><p class="math-container">\[\begin{align*}
\boldsymbol{0} &amp;= \boldsymbol{r}(t_{n + 1 - \alpha_{F}}, \boldsymbol{u}_{n + 1 - \alpha_{F}}, \partial_{t} \boldsymbol{u}_{n + 1 - \alpha_{F}}, \partial_{tt} \boldsymbol{u}_{n + 1 - \alpha_{M}}), \\
t_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} t_{n} + (1 - \alpha_{F}) t_{n+1}, \\
\boldsymbol{u}_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} \boldsymbol{u}_{n} + (1 - \alpha_{F}) \boldsymbol{u}_{n+1}, \\
\partial_{t} \boldsymbol{u}_{n + 1 - \alpha_{F}} &amp;= \alpha_{F} \partial_{t} \boldsymbol{u}_{n} + (1 - \alpha_{F}) \partial_{t} \boldsymbol{u}_{n+1}, \\
\partial_{tt} \boldsymbol{u}_{n + 1 - \alpha_{M}} &amp;= \alpha_{M} \partial_{tt} \boldsymbol{u}_{n} + (1 - \alpha_{M}) \partial_{tt} \boldsymbol{u}_{n+1}, \\
\boldsymbol{u}_{n+1} &amp;= \boldsymbol{u}_{n} + h_{n} \partial_{t} \boldsymbol{u}_{n} + \frac{1}{2} h_{n}^{2} [(1 - 2 \beta) \partial_{tt} \boldsymbol{u}_{n} + 2 \beta \boldsymbol{x}] \\
\partial_{t} \boldsymbol{u}_{n+1} &amp;= \partial_{t} \boldsymbol{u}_{n} + h_{n} [(1 - \gamma) \partial_{tt} \boldsymbol{u}_{n} + \gamma \boldsymbol{x}], \\
\partial_{tt} \boldsymbol{u}_{n+1} &amp;= \boldsymbol{x}
\end{align*}\]</p><p>The state vector is then updated to <span>$\\{\boldsymbol{s}\\}\_{n+1} = \\{\boldsymbol{u}\_{n+1}, \partial_{t} \boldsymbol{u}\_{n+1}, \partial_{tt} \boldsymbol{u}_{n+1}\\}$</span>.</p><p><strong>Analysis</strong> The amplification matrix for the state vector is</p><p class="math-container">\[\boldsymbol{A}(z) = \frac{1}{1 - \alpha_{M} + (1 - \alpha_{F}) \beta z^{2}} \begin{bmatrix}
1 - \alpha_{M} - \alpha_{F} \beta z^{2} &amp; 1 - \alpha_{M} &amp; \frac{1}{2} (1 - 2 \beta) (1 - \alpha_{M}) - \beta \alpha_{M} \\
-\gamma z^{2} &amp; (1 - \alpha_{M}) + (1 - \alpha_{F})(\beta - \gamma) z^{2} &amp; (1 - \alpha_{M}) (1 - \gamma) - \alpha_{M} \gamma + (1 - \alpha_{F}) [(1 - \gamma) \beta - \frac{1}{2} (1 - 2 \beta) \gamma] z^{2} \\
-z^{2} &amp; -(1 - \alpha_{F}) z^{2} &amp; -\alpha_{M} - \frac{1}{2} (1 - \alpha_{F}) (1 - 2 \beta) z^{2}
\end{bmatrix}.\]</p><p>Here again, we immediately see that <span>$\boldsymbol{u}_{n+1}$</span> satisfies the recurrence</p><p class="math-container">\[\boldsymbol{u}_{n+1} = \mathrm{tr}(\boldsymbol{A}(z)) \boldsymbol{u}_{n} - \frac{1}{2} (\mathrm{tr}(\boldsymbol{A}(z))^{2} - \mathrm{tr}(\boldsymbol{A}(z)^{2})) \boldsymbol{u}_{n-1} + \det(\boldsymbol{A}(z)) \boldsymbol{u}_{n-2}.\]</p><p>By plugging the Taylor expansion of <span>$\boldsymbol{u}$</span> at times <span>$t_{n+1}$</span>, <span>$t_{n-1}$</span> and <span>$t_{n-2}$</span>, we obtain the exactness condition <span>$\cos(z) = \mathrm{tr}(\boldsymbol{A}(z)) - \frac{1}{2} (\mathrm{tr}(\boldsymbol{A}(z))^{2} - \mathrm{tr}(\boldsymbol{A}(z)^{2})) \cos(z) + \det(\boldsymbol{A}(z)) \cos(2z).$</span> These conditions are hard to examine analytically, but one can verify that this scheme is at least of order <span>$1$</span>. Second-order is achieved by setting <span>$\gamma = \frac{1}{2} - \alpha_{M} + \alpha_{F}$</span>.</p><p>It is easier to consider the limit cases <span>$|z| \to 0$</span> and <span>$|z| \to +\infty$</span> and look at the eigenvalues of the amplification matrix.</p><ul><li>When <span>$|z| \to 0$</span>, we find <span>$\rho(\\boldsymbol{A}(z)) = \max\\{1, \left|\frac{\alpha_{M}}{1 - \alpha_{M}}\right|\\}$</span>.</li><li>When <span>$|z| \to +\infty$</span>, we find <span>$\rho(\\boldsymbol{A}(z)) = \max\\{\left|\frac{\alpha_{F}}{1 - \alpha_{F}}\right|, \left|\frac{4 \beta - (1 + 2 \gamma) \pm \sqrt{(1 + 2 \gamma)^{2} - 16 \beta}}{4 \beta}\right|\\}$</span>.</li></ul><p>For all these eigenvalues to have a modulus smaller than one, we need <span>$\alpha_{M} \leq \frac{1}{2}$</span>, <span>$\alpha_{F} \leq \frac{1}{2}$</span>, <span>$\gamma \geq \frac{1}{2}$</span>, i.e. <span>$\alpha_{F} \geq \alpha_{M}$</span> and <span>$\beta \geq \frac{1}{2} \gamma$</span>. Since dissipation of high-frequency is maximised when the eigenvalues are real at infinity, we also impose <span>$\beta = \frac{1}{16} (1 + 2 \gamma)^{2}$</span>, i.e. <span>$\beta = \frac{1}{4} (1 - \alpha_{M} + \alpha_{F})^{2}$</span>.</p><p>This method was also designed to damp high-frequency perturbations so it is common practice to parameter this scheme in terms of its spectral radius.</p><ul><li>The Hilbert-Huges-Taylor- <span>$\alpha$</span> (HHT- <span>$\alpha$</span>) method is obtained by setting <span>$\alpha_{M} = 0$</span>, <span>$\alpha_{F} = \frac{1 - \rho_{\infty}}{1 + \rho_{\infty}}$</span>.</li><li>The Wood-Bossak-Zienkiewicz- <span>$\alpha$</span> (WBZ- <span>$\alpha$</span>) method is recovered by setting <span>$\alpha_{F} = 0$</span> and <span>$\alpha_{M} = \frac{\rho_{\infty} - 1}{\rho_{\infty} + 1}$</span>.</li><li>The standard generalised- <span>$\alpha$</span> method is obtained by setting <span>$\alpha_{M} = \frac{2 \rho_{\infty - 1}}{\rho_{\infty} + 1}$</span>, <span>$\alpha_{F} = \frac{\rho_{\infty}}{\rho_{\infty} + 1}$</span>.</li><li>The Newmark method corresponds to <span>$\alpha_{F} = \alpha_{M} = 0$</span>. In this case, the values of <span>$\beta$</span> and <span>$\gamma$</span> are usually chosen as <span>$\beta = 0$</span>, <span>$\gamma = \frac{1}{2}$</span> (explicit central difference scheme), or <span>$\beta = \frac{1}{4}$</span> and <span>$\gamma = \frac{1}{2}$</span> (midpoint rule).</li></ul><h1 id="TODO"><a class="docs-heading-anchor" href="#TODO">TODO</a><a id="TODO-1"></a><a class="docs-heading-anchor-permalink" href="#TODO" title="Permalink"></a></h1><p>Some Runge-Kutta schemes have the First-Same-As-Last (FSAL) property, that enables sharing a residual evaluation from one step to the next. It may not be possible to have this optimisation in our case because of the Dirichlet boundary conditions.</p><h1 id="Ideas-for-later"><a class="docs-heading-anchor" href="#Ideas-for-later">Ideas for later</a><a id="Ideas-for-later-1"></a><a class="docs-heading-anchor-permalink" href="#Ideas-for-later" title="Permalink"></a></h1><ul><li>Adaptive time-stepping with embedded Runge-Kutta methods or Richardson extrapolation</li><li>Linear multistep methods (Adam-Bashford, Adam-Moulton, Backward Difference Formula)</li><li>General linear methods</li><li>Numerical methods for differential-algebraic systems of equations (DAEs)</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 April 2024 19:49">Thursday 11 April 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
